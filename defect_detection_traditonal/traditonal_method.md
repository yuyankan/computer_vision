# cv2.GaussianBlur(image_grey, block size,0) 函数，它执行的是高斯模糊。

## 原理详解
高斯模糊是一种非常常见的图像平滑（或模糊）技术，它的原理是：

### 加权平均：
它使用一个高斯函数（也叫正态分布曲线）作为权重，对图像中每个像素及其周围的像素进行加权平均。

### 平滑效果：
离中心像素越近的点，权重越大；离中心像素越远的点，权重越小。这样，高斯模糊在平滑图像的同时，能够比简单的均值模糊更好地保留图像的边缘信息。

### 减少噪声：
高斯模糊可以有效地去除图像中的高频噪声（例如椒盐噪声），使图像更加平滑。

### 代码中的参数
gray：输入图像，必须是灰度图。

(5, 5)：这是高斯核的大小，它必须是奇数。这个值越大，图像平滑的效果越明显，模糊程度也越高。

0：
这是 sigmaX 参数，代表高斯函数在X方向的标准差。当设置为 0 时，函数会根据高斯核的大小（(5, 5)）自动计算出合适的标准差。

### 为什么在二值化前使用高斯模糊？
在高斯模糊之后再进行二值化，是一个非常好的实践，原因有两点：

### 减少噪声干扰：
二值化处理对噪声非常敏感。如果图像中有细小的噪声点，二值化可能会产生错误的白点或黑点。高斯模糊可以平滑这些噪声，使二值化结果更准确。

### 平滑图像：
高斯模糊可以平滑图像中的细节，使物体和背景的边界更清晰。这对于后续的二值化处理和轮廓检测都非常有帮助。

# 1. cv2.threshold / cv2.adaptiveThreshold - 图像二值化
目的：
将一张灰度图转换成只有黑白两种像素值的二值图像。这是后续轮廓查找的基础。

原理：
通过设定一个阈值（Threshold），将图像的像素点分为前景和背景。

自动计算：
我们讨论了两种自动计算阈值的方法：

## 大津法 (cv2.THRESH_OTSU)：
假设图像直方图是双峰的，自动找到一个最佳的全局阈值来分割前景和背景。适用于光照均匀的图像。

## 自适应阈值 (cv2.adaptiveThreshold)：cv2.adaptiveThreshold(..., 11, 5)
blockSize (11) 决定了用于计算局部阈值的邻域大小。
C:5

cv2.adaptiveThreshold 的原理是，对于每一个像素，它会查看其周围 11x11 大小的区域，然后计算这个区域的平均亮度。
根据图像的局部区域动态地计算阈值，能有效处理光照不均匀的图像。
cv2.adaptiveThreshold 的核心是 阈值 = 局部平均值 - C。
cv2.THRESH_BINARY_INV 的规则：像素值 ≤ 阈值 → 白色；像素值 > 阈值 → 黑色。
### 识别不出来， 调blocksize, 更大
### 识别过多: -杂音， 调C: 更大


# 2. cv2.morphologyEx (闭运算) - 填充孔洞
目的：
填充前景物体内部的小孔洞，并连接相邻的断裂部分。
# 闭运算是填充白色前景物体中的黑色空洞。

原理：
这是一个形态学操作，由**膨胀（Dilation）和腐蚀（Erosion）**组合而成。

膨胀：先将前景（白色）区域向外扩展，以填补孔洞。

腐蚀：再将前景区域向内收缩，以恢复其原始大小，同时保留被填充的孔洞。

# 3. cv2.findContours - 查找轮廓
目的：在二值图像中查找并提取所有前景物体的轮廓。

原理：该函数会分析图像中所有相连的白色像素点，并将其边界提取出来。它将这些边界点的坐标存储在一个列表中。

参数设置：

cv2.RETR_EXTERNAL：
只查找最外层的轮廓，忽略所有内部的轮廓，非常适合你的需求。

cv2.CHAIN_APPROX_SIMPLE：
压缩轮廓的点，只保留关键的顶点，减少了内存占用和后续处理的复杂度。

这三个函数协同工作，形成了一个完整的图像处理流程：先通过二值化分离前景，然后通过形态学操作优化前景，最后通过轮廓检测提取出你想要的缺陷轮廓。
